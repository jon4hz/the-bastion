#!/usr/bin/perl -T
# vim: set filetype=perl ts=4 sw=4 sts=4 et:
# KEYSUDOERS # generate sshd port forwarding configs for accounts
# KEYSUDOERS SUPEROWNERS ALL=(root) NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-genSSHPFConfigs --account %USER%
# KEYSUDOERS OWNERS ALL=(root) NOPASSWD: /usr/bin/env perl -T %BASEPATH%/bin/helper/osh-genSSHPFConfigs --account %USER%
# FILEMODE 0755
# FILEOWN 0 0

#>HEADER
use common::sense;
use Getopt::Long qw(:config no_auto_abbrev no_ignore_case);

use File::Basename;
use lib dirname(__FILE__) . '/../../lib/perl';
use OVH::Bastion;
use OVH::Bastion::Helper;

# Fetch command options
my $fnret;
my ($result,  @optwarns);
my ($account, $all_accounts);
eval {
    local $SIG{__WARN__} = sub { push @optwarns, shift };
    $result = GetOptions(
        "account=s"     => sub { $account //= $_[1] },
        "all-accounts!" => \$all_accounts,
    );
};
if ($@) { die $@ }

if (!$result) {
    local $" = ", ";
    HEXIT('ERR_BAD_OPTIONS', msg => "Error parsing options: @optwarns");
}

OVH::Bastion::Helper::check_spurious_args();

if (!$account && !$all_accounts) {
    HEXIT('ERR_MISSING_PARAMETER', msg => "Missing argument 'account' or 'all-accounts'");
}

if ($account && $all_accounts) {
    HEXIT('ERR_INVALID_PARAMETER', msg => "Cannot specify both 'account' and 'all-accounts'");
}

#<HEADER

# Check if port forwarding is enabled
$fnret = OVH::Bastion::load_configuration();
if (!$fnret) {
    HEXIT('ERR_CONFIGURATION', msg => "Failed to load configuration");
}
my $config = $fnret->value;

if (!$config->{'portForwardingEnabled'} || !$config->{'portForwardingSSHConfigEnabled'}) {
    # Port forwarding is disabled, clean up any existing configs
    osh_info("Port forwarding disabled or ssh config generation disabled, cleaning up all SSH port forward configs");
    system("/bin/rm",        "-rf", "/etc/ssh/sshd_config.forward.d/");
    system("/usr/bin/mkdir", "-p",  "/etc/ssh/sshd_config.forward.d/");
    HEXIT('OK', msg => "Port forwarding is disabled, configs cleaned up");
}

# Ensure the directory exists
system("/usr/bin/mkdir", "-p", "/etc/ssh/sshd_config.forward.d/");

my @accounts_to_process;
if ($all_accounts) {
    # Get all bastion accounts
    $fnret = OVH::Bastion::get_account_list();
    if (!$fnret) {
        HEXIT('ERR_CANNOT_GET_ACCOUNT_LIST', msg => "Cannot get account list");
    }
    @accounts_to_process = keys %{$fnret->value};
}
else {
    @accounts_to_process = ($account);
}

my $configs_generated = 0;
my $configs_removed   = 0;

foreach my $acc (@accounts_to_process) {
    # Skip system accounts
    my %system_accounts = map { $_ => 1 } qw(root bastionsync healthcheck keykeeper keyreader allowkeeper proxyhttp lastoshuser);
    next if exists $system_accounts{$acc};

    # Validate account exists
    $fnret = OVH::Bastion::is_bastion_account_valid_and_existing(account => $acc);
    if (!$fnret) {
        osh_warn("Skipping invalid account $acc");
        next;
    }

    my $account_info  = $fnret->value;
    my $sysaccount    = $account_info->{'sysaccount'};
    my $remoteaccount = $account_info->{'remoteaccount'};

    # Untaint the account name for file operations
    my $safe_acc = $acc;
    if ($safe_acc =~ /^([a-zA-Z0-9._-]+)$/) {
        $safe_acc = $1;    # Untainted
    }
    else {
        osh_warn("Invalid account name format: $acc");
        return R('KO_INVALID_PARAMETER', msg => "Invalid account name format");
    }

    my $config_file = "/etc/ssh/sshd_config.forward.d/$safe_acc.conf";

    # Collect all port forwarding rules for this account
    my @permit_opens = ();
    my @local_ports  = ();    # Track local ports for PermitListen

    # 1. Personal port forwards
    my $personal_file = "/home/allowkeeper/$sysaccount/allowed.forward";
    if (-r $personal_file) {
        $fnret = OVH::Bastion::get_port_forwards_from_file(file => $personal_file);
        if ($fnret && $fnret->value) {
            foreach my $rule (@{$fnret->value}) {
                my $permit_open = _generate_permit_open($rule);
                if ($permit_open) {
                    push @permit_opens,
                      {
                        line   => $permit_open,
                        source => "personal access"
                      };
                    # Collect local port for PermitListen
                    if ($rule->{local_port} && $rule->{local_port} =~ /^\d+$/) {
                        push @local_ports, $rule->{local_port};
                    }
                }
            }
        }
    }

    # 2. Group port forwards (through symlinks)
    # remote account for realm support(?)
    my $prefix        = $remoteaccount ? "allowed_$remoteaccount" : "allowed";
    my @symlink_files = glob("/home/allowkeeper/$sysaccount/$prefix.forward.*");
    foreach my $symlink (@symlink_files) {
        next unless -l $symlink;    # Only process symlinks
        next unless -r $symlink;    # Must be readable

        # Extract group name from symlink filename
        my $group_name = "";
        if ($symlink =~ /\Q$prefix\E\.(?:forward\.(.+)|partial\.(.+)\.forward)$/) {
            $group_name = $1 || $2;
        }

        $fnret = OVH::Bastion::get_port_forwards_from_file(file => $symlink);
        if ($fnret && $fnret->value) {
            foreach my $rule (@{$fnret->value}) {
                my $permit_open = _generate_permit_open($rule);
                if ($permit_open) {
                    push @permit_opens,
                      {
                        line   => $permit_open,
                        source => $group_name ? "group $group_name" : "group access"
                      };
                    # Collect local port for PermitListen
                    if ($rule->{local_port} && $rule->{local_port} =~ /^\d+$/) {
                        push @local_ports, $rule->{local_port};
                    }
                }
            }
        }
    }

    # Remove duplicates (merge sources for duplicate lines) and sort
    my %merged = ();
    foreach my $entry (@permit_opens) {
        my $line = $entry->{line};
        if (exists $merged{$line}) {
            # Merge sources if the same PermitOpen line comes from multiple places
            my @existing_sources = split(/, /, $merged{$line});
            push @existing_sources, $entry->{source};
            # Remove duplicates from sources
            my %seen_sources = ();
            @existing_sources = grep { !$seen_sources{$_}++ } @existing_sources;
            $merged{$line} = join(", ", sort @existing_sources);
        }
        else {
            $merged{$line} = $entry->{source};
        }
    }

    # Sort the PermitOpen lines
    my @sorted_lines = sort keys %merged;

    # Remove duplicate local ports and sort
    my %seen_ports = ();
    @local_ports = grep { !$seen_ports{$_}++ } @local_ports;
    @local_ports = sort { $a <=> $b } @local_ports;

    if (@sorted_lines) {
        # Get port forwarding configuration
        my $config_fnret = OVH::Bastion::load_configuration();
        my $min_port     = 20000;                                # Default fallback
        my $max_port     = 65535;                                # Default fallback

        if ($config_fnret && $config_fnret->value) {
            $min_port = $config_fnret->value->{'portForwardingLocalPortMin'} || $min_port;
            $max_port = $config_fnret->value->{'portForwardingLocalPortMax'} || $max_port;
        }

        # Generate config file
        my $config_content = "# SSH port forwarding config for user $acc\n";
        $config_content .= "# Generated automatically by osh-genSSHPFConfigs\n";
        $config_content .= "# DO NOT EDIT MANUALLY\n\n";
        $config_content .= "Match User $acc\n";
        $config_content .= "    AllowTcpForwarding local\n";
        $config_content .= "    GatewayPorts no\n";

        # Generate single PermitOpen line with only local listening ports
        my @local_permits = ();

        # Add local listening ports (for the client side of the tunnel)
        if (@local_ports) {
            push @local_permits, map { "localhost:$_" } @local_ports;
        }

        my $permit_destinations = join(' ', @local_permits);
        $config_content .= "    PermitOpen $permit_destinations\n";

        # Add comments showing the source of each destination
        $config_content .= "#\n# Port forwarding configuration:\n";
        if (@local_ports) {
            $config_content .= "# Local listening ports: " . join(', ', @local_ports) . "\n";
        }
        $config_content .= "\n";

        if (open(my $fh, '>', $config_file)) {
            print $fh $config_content;
            close($fh);
            chmod(0644, $config_file);

            # Validate the generated config file syntax
            if (_validate_ssh_config_file($config_file)) {
                $configs_generated++;
                osh_debug("Generated SSH config for $acc with " . scalar(@local_ports) . " local port(s)");
            }
            else {
                osh_warn("Generated SSH config for $acc failed validation, removing file");
                unlink($config_file);
            }
        }
        else {
            osh_warn("Failed to write config file $config_file: $!");
        }
    }
    else {
        # No port forwards, remove config file if it exists
        if (-f $config_file) {
            unlink($config_file);
            $configs_removed++;
            osh_debug("Removed SSH config for $acc (no port forwards)");
        }
    }
}

# Validate SSH configuration before reloading
osh_debug("Validating SSH configuration before reload...");
my $validation_result = system("/usr/sbin/sshd", "-t");
if ($validation_result != 0) {
    osh_warn("SSH configuration validation failed! Not reloading daemon to prevent service disruption.");
    HEXIT('ERR_SSH_CONFIG_INVALID',
        msg => "SSH configuration validation failed. Generated configs may contain errors. Please check manually.");
}
osh_debug("SSH configuration validation passed");

# Reload SSH daemon
my $reload_result = system("/usr/bin/systemctl", "reload", "sshd");
if ($reload_result != 0) {
    osh_warn("Failed to reload SSH daemon");
}
else {
    osh_debug("SSH daemon reloaded successfully");
}

my $msg = "";
if ($configs_generated > 0) {
    $msg .= "Generated $configs_generated SSH port forward config(s). ";
}
if ($configs_removed > 0) {
    $msg .= "Removed $configs_removed SSH port forward config(s). ";
}
if ($reload_result == 0) {
    $msg .= "SSH daemon reloaded successfully.";
}
else {
    $msg .= "SSH daemon reload failed.";
}

HEXIT('OK', msg => $msg);

# Generate PermitOpen directive from port forward rule
sub _generate_permit_open {
    my ($rule) = @_;

    return unless $rule && ref($rule) eq 'HASH';

    my $remote_ip    = $rule->{'remote_ip'};
    my $forward_port = $rule->{'forward_port'};

    return unless $remote_ip;

    # Handle IPv6 addresses
    if ($remote_ip =~ /:/ && $remote_ip !~ /^\[.*\]$/) {
        $remote_ip = "[$remote_ip]";
    }

    # Handle port wildcards
    if (!defined $forward_port || $forward_port eq '*') {
        return "$remote_ip:*";
    }
    else {
        return "$remote_ip:$forward_port";
    }
}

# Validate an individual SSH config file
sub _validate_ssh_config_file {
    my ($config_file) = @_;

    return 0 unless $config_file && -f $config_file;

    # Use sshd -T with the specific config file to test syntax
    # We create a temporary minimal config that includes our file
    my $temp_config = "/tmp/sshd_test_" . $$ . ".conf";

    # Untaint the temp filename
    if ($temp_config =~ /^(\/tmp\/sshd_test_\d+\.conf)$/) {
        $temp_config = $1;
    }
    else {
        return 0;
    }

    if (open(my $fh, '>', $temp_config)) {
        print $fh "# Temporary config for validation\n";
        print $fh "PidFile /dev/null\n";    # Prevent actual daemon startup
        print $fh "Include $config_file\n";
        close($fh);

        # Test the configuration syntax only, redirect stderr to capture host key warnings
        my $test_result = system("/usr/sbin/sshd -t -f $temp_config 2>/dev/null");
        unlink($temp_config);

        return $test_result == 0;
    }

    return 0;
}
